---
title: Symbol resolution & Relocation
authors:
    - xman
date:
    created: 2023-06-27T15:00:00
categories:
    - elf
comments: true
---

In this article I'll explore the basic concepts associated with static linking - symbol resolution and relocation.

<!-- more -->

[Computer Systems - A Programmer's Perspective](https://www.amazon.com/Computer-Systems-OHallaron-Randal-Bryant/dp/1292101768/) | Chapter 7: Linking

- 7.2: Static Linking
- 7.3: Object Files
- 7.5: Symbols and Symbol Tables
- 7.6: Symbol Resolution
- 7.7: Relocation

## Static Linking

Static linkers such as the Linux `ld` program take as input a collection of *relocatable* object files and command-line arguments and generate as output a fully linked executable object file that can be loaded and run. The input relocatable object files consist of various code and data sections, where each section is a contiguous sequence of bytes. Instructions are in one section, initialized global variables are in another section, and uninitialized variables are in yet another section.

To build the executable, the linker must perform two main tasks:

1. **`Symbol resolution`**. Object files define and reference `symbols`, where each symbol corresponds to a function, a global variable, or a static variable (i.e., any C variable declared with the *static* attribute). The purpose of symbol resolution is to **associate** each symbol reference with exactly one symbol definition.

2. **`Relocation`**. Compilers and assemblers generate code and data sections that start at address 0. The linker **relocates** these sections by *associating* a memory location with each symbol definition, and then *modifying* all of the references to those symbols so that they point to this memory location. The linker blindly performs these relocations using detailed instructions, generated by the assembler, called `relocation entries`.

The sections that follow describe these tasks in more detail. As you read, keep in mind some basic facts about linkers: Object files are merely collections of blocks of bytes. Some of these blocks contain program code, others contain program data, and others contain data structures that guide the linker and loader. A linker **concatenates** blocks together, decides on run-time locations for the concatenated blocks, and **modifies** various locations within the code and data blocks. Linkers have minimal understanding of the target machine. The compilers and assemblers that generate the object files have already done most of the work.

## Object Files

Object files come in three forms:

1. *`Relocatable object file`*. Contains binary code and data in a form that can be combined with other relocatable object files at compile time to create an executable object file.

2. *`Executable object file`*. Contains binary code and data in a form that can be copied directly into memory and executed.

3. *`Shared object file`*. A special type of relocatable object file that can be loaded into memory and linked dynamically, at either load time or run time.

Compilers and assemblers generate relocatable object files (including *shared* object files). Linkers generate executable object files. Technically, an *object module* is a sequence of bytes, and an *object file* is an object module stored on disk in a file. However, we will use these terms interchangeably.

Object files are organized according to specific *object file formats*, which vary from system to system. The first Unix systems from Bell Labs used the `a.out` format. (To this day, executables are still referred to as `a.out` files.) Windows uses the Portable Executable (`PE`) format. Mac OS-X uses the `Mach-O` format. Modern x86-64 Linux and Unix systems use Executable and Linkable Format (`ELF`). Although our discussion will focus on ELF, the basic concepts are similar, regardless of the particular format.

Type        | Generator | Loadable | Suffixes
------------|-----------|----------|---------
Relocatable | assembler | No       | `.o`
Executable  | linker    | Yes      |
Shared      | linker    | No       | `.so`

For target files in Linux, from a technical point of view, the file suffix can be *arbitrary*, or no suffix at all, and the usual file suffix is just for ease of distinction. In fact, in the Linux system, the target file type is defined in a field in the *ELF* header(field `e_type` of Elf32_Ehdr/Elf64_Ehdr), and the system determines the true type of the target file by the value of this field, rather than by the extension of the target file.

The generator in the above table refers specifically to the part directly involved in the process of generating the target file. For example, the *executable* target file generator is the linker, of course the compiler and assembler are also involved in this process, but the latter two are involved indirectly. Meanwhile, practice has shown that the *linker* is involved in the process of creating shareable object files. So we specify its generator as *linker* instead of the latter two.

## Symbols

Each relocatable object module, *m*, has a symbol table that contains information about the symbols that are defined and referenced by *m*. In the context of a linker, there are three different kinds of symbols:

- *`Global symbols`* that are defined by module *m* and that can be referenced by other modules. Global linker symbols correspond to *nonstatic* C functions and global variables.

- *`Global symbols`* that are referenced by module *m* but defined by some other module. Such symbols are called `externals` and correspond to *nonstatic* C functions and global variables that are defined in other modules.

- *`Local symbols`* that are defined and referenced exclusively by module *m*. These correspond to *static* C functions and global variables that are defined with the static attribute. These symbols are visible anywhere within module *m*, but cannot be referenced by other modules.

!!! note "local linker symbols vs. local program variables"

    It is important to realize that local linker symbols are not the same as local program variables. The symbol table in `.symtab` does not contain any symbols that correspond to local nonstatic program variables. These are managed at run time on the stack and are not of interest to the linker.

    Interestingly, local procedure variables that are defined with the C static attribute are not managed on the *stack*. Instead, the compiler allocates space in `.data` or `.bss` for each definition and creates a local linker symbol in the symbol table with a unique name.

## Resolution

The linker **resolves** symbol references by *associating* each reference with exactly one symbol definition from the symbol tables of its input relocatable object files. Symbol resolution is straightforward for references to local symbols that are defined in the same module as the reference. The compiler allows *only* one definition of each local symbol per module. The compiler also ensures that static local variables, which get local linker symbols, have *unique* names.

Resolving references to global symbols, however, is trickier. When the compiler encounters a symbol (either a variable or function name) that is *not* defined in the current module, it assumes that it is defined in some *other* module, generates a linker symbol table entry, and leaves it for the linker to handle. If the linker is unable to find a definition for the referenced symbol in any of its input modules, it prints an (often cryptic) error message and terminates.

Symbol resolution for global symbols is also tricky because *multiple* object modules might define global symbols with the same name. In this case, the linker must either flag an error or somehow choose one of the definitions and discard the rest. The approach adopted by Linux systems involves cooperation between the compiler, assembler, and linker and can introduce some baffling bugs to the unwary programmer.

## Relocation

Once the linker has completed the symbol resolution step, it has **associated** each symbol reference in the code with exactly one symbol definition (i.e., a symbol table entry in one of its input object modules). At this point, the linker knows the exact sizes of the code and data sections in its input object modules. It is now ready to begin the relocation step, where it **merges** the input modules and assigns run-time addresses to each symbol. Relocation consists of two steps:

1. Relocating sections and symbol definitions. In this step, the linker **merges** all sections of the same type into a new aggregate section of the same type. For example, the `.data` sections from the input modules are all merged into one section that will become the `.data` section for the output executable object file. The linker then assigns run-time memory addresses to the new aggregate sections, to each section defined by the input modules, and to each symbol defined by the input modules. When this step is complete, each instruction and global variable in the program has a unique run-time memory address.

2. Relocating symbol references within sections. In this step, the linker **modifies** every symbol reference in the bodies of the code and data sections so that they point to the correct run-time addresses. To perform this step, the linker relies on data structures in the relocatable object modules known as `relocation entries`, which we describe next.

When an assembler generates an object module, it does not know where the code and data will ultimately be stored in memory. Nor does it know the locations of any externally defined functions or global variables that are referenced by the module. So whenever the assembler encounters a reference to an object whose ultimate location is unknown, it generates a relocation entry that tells the linker how to modify the reference when it merges the object file into an executable. Relocation entries for code are placed in `.rel.text`(`.rela.plt` for DYN). Relocation entries for data are placed in `.rel.data`(`.rela.dyn` for DYN).
