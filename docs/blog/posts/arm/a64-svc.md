---
title: ARM64 System calls
authors:
  - xman
date:
    created: 2023-06-04T09:00:00
categories:
    - arm
tags:
    - exception
    - syscall
comments: true
---

Software interrupts, or *SVCs* as they are now known, are generated by using the ARM instruction `SVC`. This causes an exception to be taken, and forces the processor into Supervisor mode, which is privileged. A user program can request services from an operating system through such exception handling mechanisms.

<!-- more -->

## arm system calls

### A64 Instruction Set Architecture

[Learn the architecture - A64 Instruction Set Architecture Guide](https://developer.arm.com/documentation/102374/latest) | 28. System calls

Sometimes it is necessary for software to request a function from a more *privileged* entity. This might happen when, for example, an application requests that the OS opens a ﬁle.

In A64, there are special instructions for making such system calls. These instructions cause an exception, which allows controlled entry into a more *privileged* Exception level.

- `SVC` Supervisor call causes an exception targeting `EL1`. Used by an application to call the OS.
- `HVC` Hypervisor call causes an exception targeting `EL2`. Used by an OS to call the hypervisor, not available at `EL0`.
- `SMC` Secure monitor call causes an exception targeting `EL3`. Used by an OS or hypervisor to call the `EL3` ﬁrmware, not available at `EL0`.

If an exception is executed from an Exception level higher than the target exception level, then the exception is taken to the current Exception level. This means that an `SVC` at `EL2` would cause exception entry to `EL2`. Similarly, an `HVC` at `EL3` causes exception entry to `EL3`. This is consistent with the rule that an exception can never cause the processor to lose privilege.

### Programmer's Guide for ARMv8-A

[ARM Cortex-A Series Programmer's Guide for ARMv8-A](https://developer.arm.com/documentation/den0024/latest)

6.5 System control and other instructions - 6.5.1 Exception handling instructions

There are three exception handling instructions whose purpose it is to cause an exception to be taken. These are used to make a call to code that runs in a higher Exception level in the OS (`EL1`), the Hypervisor (`EL2`), or Secure Monitor (`EL3`):

- `SVC #imm16` // Supervisor call, allows application program to call the kernel // (EL1).
- `HVC #imm16` // Hypervisor call, allows OS code to call hypervisor (EL2).
- `SMC #imm16` // Secure Monitor call, allows OS or hypervisor to call Secure // Monitor (EL3).

The immediate value is made available to the handler in the *Exception Syndrome Register*. This is a change from ARMv7, where the immediate value had to be determined by reading the opcode of the calling instruction. See Chapter 10 AArch64 Exception Handling for further information.

To return from an exception, use the `ERET` instruction. This instruction restores processor state by copying `SPSR_ELn` to PSTATE and branches to the saved return address in `ELR_ELn`.

---

10: AArch64 Exception Handling - Exception generating instructions

Execution of certain instructions can generate exceptions. Such instructions are typically executed to request a service from software that runs at a higher privilege level:

- The Supervisor Call (`SVC`) instruction enables User mode programs to request an OS service.
- The Hypervisor Call (`HVC`) instruction enables the guest OS to request hypervisor services.
- The Secure monitor Call (`SMC`) instruction enables the Normal world to request Secure world services.

If the resulting exception was generated as a result of an instruction fetch at `EL0`, it is taken as an exception to `EL1`, unless the `HCR_EL2`.TGE bit is set in the Non-secure state, in which case it is taken to `EL2`.

If the exception was generated as a result of an instruction fetch at any other Exception level, the Exception level remains unchanged.

Earlier in the book, we saw that the ARMv8-A architecture has four Exception levels. Processor execution can only move between Exception levels by taking, or returning from, an exception. When the processor moves from a higher to a lower Exception level, the execution state can stay the same, or it can switch from AArch64 to AArch32. Conversely, when moving from a lower to a higher Exception level, the execution state can stay the same or switch from AArch32 to AArch64.

<figure markdown="span">
    ![A64-Exception-flow](./images/A64-Exception-flow.png){: style="width:80%;height:80%"}
    <figcaption>Figure 10.1. Exception flow</figcaption>
</figure>

Figure 10-1 shows schematically the program flow associated with an exception occurring when running an application. The processor branches to a vector table which contains entries for each exception type. The vector table contains a dispatch code which typically identifies the cause of the exception, and select and call the appropriate function to handle it. This code completes execution and then return to the high-level handler which then executes the ERET instruction to return to the application.

---

10.2 Synchronous and asynchronous exceptions

10.2.3 System calls

Some instructions or system functions can only be carried out at a *specific* Exception level. If code running at a lower Exception level needs to perform a privileged operation, for example, when application code requests functionality from the kernel. One way to do this is by using the `SVC` instruction. This allows applications to **generate** an exception. Parameters may be passed in registers, or coded within the System call.

10.2.4 System calls to EL2/EL3

We saw earlier how `SVC` may be used to call from user applications at `EL0` to the kernel at `EL1`. The `HVC` and `SMC` system call instructions move the processor in a similar fashion to `EL2` and `EL3`. When the processor is executing at `EL0` (Application), it cannot call directly into the hypervisor (`EL2`) or Secure monitor (`EL3`). This is only possible from `EL1` and above. Applications must therefore use `SVC` to call into kernel and allow the kernel to call into higher Exception levels on their behalf.

From the OS kernel (`EL1`), software can call the hypervisor (`EL2`) with the `HVC` instruction, or call the Secure monitor (`EL3`) with the SMC instruction. If the processor is implemented with `EL3`, the ability to have `EL2` trap `SMC` instructions from `EL1` is provided. If there is no `EL3`, the `SMC` is unallocated and triggers at the current Exception level.

Similarly, from hypervisor code (`EL2`), the program can call the Secure monitor (`EL3`) with the SMC instruction. If you make an `SVC` call when in `EL2` or `EL3` it will still cause a synchronous exception at the same Exception level, and the handler for that Exception level can decide how to respond.

## linux syscall

[What is the interface for ARM system calls and where is it defined in the Linux kernel?](https://stackoverflow.com/questions/12946958/what-is-the-interface-for-arm-system-calls-and-where-is-it-defined-in-the-linux)

[syscall(2) - Linux manual page](https://man7.org/linux/man-pages/man2/syscall.2.html#NOTES) - Architecture calling conventions

[Chromium OS Docs - Linux System Call Table](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#arm64-64_bit)

- [Linux System Calls quick and easy](https://syscall.sh/)
- [Linux system calls table for several architectures](https://gpages.juszkiewicz.com.pl/syscalls-table/syscalls.html)

arch    | syscall NR | return | arg0 | arg1 | arg2 | arg3 | arg4 | arg5
--------|------------|--------|------|------|------|------|------|-----
arm     | r7         | r0     | r0   | r1   | r2   | r3   | r4   | r5
arm64   | x8         | x0     | x0   | x1   | x2   | x3   | x4   | x5
x86     | eax        | eax    | ebx  | ecx  | edx  | esi  | edi  | ebp
x86_64  | rax        | rax    | rdi  | rsi  | rdx  | r10  | r8   | r9

---

[SVC](https://developer.arm.com/documentation/ddi0602/2024-03/Base-Instructions/SVC--Supervisor-Call-?lang=en): Supervisor Call causes an exception to be taken to `EL1`.

[Programming with 64-Bit ARM Assembly Language: Single Board Computer Development for Raspberry Pi and Mobile Devices](https://www.amazon.com/Programming-64-Bit-ARM-Assembly-Language/dp/1484258800/) | Chapter 7: Linux Operating System Services - Calling Convention - Linux System Call Numbers

The Linux system call numbers are defined in the C include file: [/usr/include/asm-generic/unistd.h](https://github.com/torvalds/linux/blob/ea5f6ad9ad9645733b72ab53a98e719b460d36a6/include/uapi/asm-generic/unistd.h)

In this file, there are define statements such as the following:

```c title="/usr/include/asm-generic/unistd.h"
/* fs/read_write.c */
#define __NR_write 64

/* kernel/exit.c */
#define __NR_exit 93
```

This defines the symbol `__NR_write` to represent the magic number 64 for the [write](https://man7.org/linux/man-pages/man2/write.2.html) Linux system call and 93 for exit.

## demo

Request Linux service to write a string of bytes/characters to the standard output device.

=== "svc64.s"

    ```asm linenums="1"
            .text
            .align 2

            // syscall NR defined in /usr/include/asm-generic/unistd.h
            .equ    __NR_write, 64       // 0x40
            .equ    __NR_exit, 93        // 0x5d
            .equ    __STDOUT, 1

            .global  _start              // Provide program starting address to linker
    _start:
            mov     x0, #__STDOUT        // target fd=stdout (standard output, i.e., monitor)
            ldr     x1, =msgtxt          // Set x1 pointing to message to be displayed
            mov     x2, #10              // Number of bytes in message
            mov     x8, #__NR_write      // Linux service command code to write string.
            svc     0                    // Issue command to display string on stdout
            mov     x0, #0               // Exit Status code 0 for "normal completion"
            mov     x8, #__NR_exit       // Service command code to terminate this program
            svc     0                    // Issue Linux command to terminate program
            .data
    msgtxt: .ascii  "Hey there\n"        // 10 character message (blank and In each count as 1 char.)
            .end
    ```

=== "equivalent svc64.c"

    ```c
    #include <stdio.h>

    int main(int argc, char *argv[])
    {
        puts("Hey there");

        return 0;
    }
    ```

Compile, link and run in rpi3b-ubuntu/aarch64:

```Shell
# compile assembly to object
$ as svc64.s -o svc64.o
# link object to executable binary
$ ld svc64.o -o svc64
# execute binary
$ ./svc64
Hey there

# cc svc64.c -o svc64 && ./svc64
```

## refs

[embedded system by venkatpari: Linux system call flow in ARM64](https://embeddedvenkatpari.blogspot.com/2022/03/linux-system-call-flow-in-arm64.html)
