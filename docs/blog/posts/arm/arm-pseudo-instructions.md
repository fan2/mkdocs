---
title: ARM pseudo-instructions
authors:
    - xman
date:
    created: 2023-06-05T09:00:00
categories:
    - arm
tags:
    - instruction
comments: true
---

Instructions and pseudo-instructions make up the code a processor uses to perform tasks.

`Directives` are commands issued to the assembler, which are processed by the assembler during source program assembly. `Pseudo-instructions` can complete functions such as selecting the processor, defining the program mode, defining data, allocating storage areas, and indicating the end of the program. In short, pseudo-instructions can be broken down into sets of several instructions.

<!-- more -->

## Pseudo-instructions

[ARM Compiler toolchain Assembler Reference](https://developer.arm.com/documentation/dui0489/latest/arm-and-thumb-instructions/pseudo-instructions) | ARM and Thumb Instructions - Pseudo-instructions
[ARM Compiler armasm Reference Guide](https://developer.arm.com/documentation/dui0802/latest/A32-and-T32-Instructions/Pseudo-instructions) | 3: A32 and T32 Instructions - 3.16 Pseudo-instructions

The ARM assembler supports a number of pseudo-instructions that are translated into the appropriate combination of A32 or T32 instructions at assembly time.

The following topics describe the pseudo-instructions:

pseudo-instruction | description
-------------------|------------
ADRL  | Load a PC-relative or register-relative address into a register <br/>(medium range, position independent).
CPY   | Copy a value from one register to another.
LDR   | Load a register with a 32-bit immediate value or an address <br/>(unlimited range, but not position independent).
MOV32 | Load a register with a 32-bit immediate value or an address <br/>(unlimited range, but not position independent).
NEG   | Negate a value in a register.
UND   | Generate an architecturally undefined instruction.

[Arm A-profile A64 ISA - Shared Pseudocode](https://developer.arm.com/documentation/ddi0602/latest/Shared-Pseudocode)

## gas ARM Opcodes

[assembly - Getting an label address to a register on ARM? - Stack Overflow](https://stackoverflow.com/questions/15774581/getting-an-label-address-to-a-register-on-arm)

[ARM Opcodes](https://sourceware.org/binutils/docs/as/ARM-Opcodes.html)

> [as](https://sourceware.org/binutils/docs/as/index.html) implements all the standard ARM opcodes. It also implements several pseudo opcodes, including several synthetic load instructions.

[AArch64 Opcodes](https://sourceware.org/binutils/docs/as/AArch64-Opcodes.html)

> `GAS`(GNU AS) implements all the standard AArch64 opcodes. It also implements several pseudo opcodes, including several synthetic load instructions.

### NOP

```asm
    nop
```

This pseudo op will always evaluate to a legal ARM instruction that does nothing. Currently it will evaluate to `MOV r0, r0`.

### LDR

```asm
    ldr <register> , = <expression>
```

If expression evaluates to a numeric constant then a `MOV` or `MVN` instruction will be used in place of the `LDR` instruction, if the constant can be generated by either of these instructions. Otherwise the constant will be placed into the nearest literal pool (if it not already there) and a PC relative `LDR` instruction will be generated.

> [AArch64 Opcodes](https://sourceware.org/binutils/docs/as/AArch64-Opcodes.html): The constant expression will be placed into the nearest literal pool (if it not already there) and a PC-relative `LDR` instruction will be generated.

### ADR

```asm
    adr <register> <label>
```

This instruction will load the address of label into the indicated register. The instruction will evaluate to a PC relative `ADD` or `SUB` instruction depending upon where the label is located. If the label is out of range, or if it is not defined in the same file (and section) as the `ADR` instruction, then an error will be generated. This instruction will not make use of the literal pool.

If label is a thumb function symbol, and thumb interworking has been enabled via the `-mthumb-interwork` option then the bottom bit of the value stored into register will be set. This allows the following sequence to work as expected:

```asm
    adr     r0, thumb_function
    blx     r0
```

### ADRL

```asm
    adrl <register> <label>
```

This instruction will load the address of label into the indicated register. The instruction will evaluate to one or *two* PC relative `ADD` or `SUB` instructions depending upon where the label is located. If a second instruction is not needed a NOP instruction will be generated in its place, so that this instruction is always 8 bytes long.

If the label is out of range, or if it is not defined in the same file (and section) as the `ADRL` instruction, then an error will be generated. This instruction will not make use of the literal pool.

If label is a thumb function symbol, and thumb interworking has been enabled via the -mthumb-interwork option then the bottom bit of the value stored into register will be set.
