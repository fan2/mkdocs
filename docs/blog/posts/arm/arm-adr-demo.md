---
title: ARM ADR/ADRP demos
authors:
    - xman
date:
    created: 2023-06-09T10:00:00
categories:
    - arm
tags:
    - instruction
comments: true
---

In the previous two articles([ARM ADR (PC-relative)](./arm-adr-ldr.md) & [ARM ADRP and ADRL pseudo-instruction](./arm-adrp-adrl.md)), we've combed AMR `ADR` instructions to load a pc-relative label address to a register.

Here we collect some enlightening demos from some classic textbooks to consolidate knowledge that is not solid.

<!-- more -->

## ADR vs. ADRP

[ARM 64-Bit Assembly Language](https://www.amazon.com/64-Bit-Assembly-Language-Larry-Pyeatt/dp/0128192216/)

3 Load/store and branch instructions - 3.5 Branch instructions - 3.5.5 Form PC-relative address

These instructions are used to calculate the address associated with a label:

- `adr`: Form PC-Relative Address
- `adrp`: Form PC-Relative Address to 4 KB Page

They are more efﬁcient than the `ldr Rx,=label` pseudo instruction, because they can calculate a 64-bit address in one or two instructions without performing a memory access. They can be used to load any address that is *within* range. If the label is out of range, then the assembler or linker will emit an error, and the programmer can change their code to use the `ldr Rx,=label` syntax.

**Syntax**

```asm
<op> Rd, <label> // <op> is either adr or adrp.
```

- `adr` has a range of ±1 MB. (21 bit immediate).
- `adrp` has a range of ±4 GB to the nearest 4 KB page (4096 bytes). The 21-bit immediate is *shifted* left by 12 bits and added to the pc.

    - The lower 12 bits of a label’s address can be added to `adrp` to exactly **address** a label.

**Operations**

Name   | Effect | Description
-------|--------|------------
`adr`  | Rd ← Address of label          | Load address with pc-relative immediate addressing.
`adrp` | Rd ← Page address of label     | Load address of the beginning of the 4-Kilobyte memory page which contains the label using pc-relative immediate addressing.

## ADRL=ADRP+ADD

In A64, `ADRL` assembles to two instructions, an `ADRP` followed by `ADD`.

[ARM relocation generation](https://sourceware.org/binutils/docs/as/ARM_002dRelocations.html) / [AArch64-Relocations](https://sourceware.org/binutils/docs/as/AArch64_002dRelocations.html)

- [assembly - AArch64 relocation prefixes - Stack Overflow](https://stackoverflow.com/questions/38570495/aarch64-relocation-prefixes)

Relocations for `ADRP`, and `ADD`, `LDR` or `STR` instructions can be generated by prefixing the label with ‘`:pg_hi21:`’ and ‘`#:lo12:`’ respectively.

For example to use 33-bit (±4GB) pc-relative addressing to load the address of *foo* into `X0`:

```asm
    adrp x0, :pg_hi21:foo
    add  x0, x0, #:lo12:foo
```

Or to load the value of *foo* into `X0`:

```asm
    adrp x0, :pg_hi21:foo
    ldr  x0, [x0, #:lo12:foo]
```
Note that ‘`:pg_hi21:`’ is optional.

- `adrp x0, foo` is equivalent to `adrp x0, :pg_hi21:foo`

<figure markdown="span">
    ![ADRL=ADRP+ADD](./images/ADRL=ADRP+ADD.png){: style="width:75%;height:75%"}
    <figcaption>ADRL = ADRP + ADD</figcaption>
</figure>

## Examples

### ADRP C runtime data

[Programming with 64-Bit ARM Assembly Language](https://www.amazon.com/Programming-64-Bit-ARM-Assembly-Language/dp/1484258800/) | Chapter 15: Reading and Understanding Code - Code Created by GCC

Listing 15-3. Assembly code generated by the C compiler for our upper-case function

```asm linenums="1" hl_lines="3 5 13-14"
  0000000000000690 <main>:
    690:        agbf7bfd        stp     x29, x30, [sp, #-16]!
    694:        b0000080        adrp    x0, 11000 <_cxa_finalize
                                                    @GLIBC_2.17>
    698:        90000082        adrp    x2, 10000  <_FRAME_END_+Oxf588>
    69C:        910003fd        mov     x29, sp

    // ...

    6e8:        381ff080        sturb w0, [x4, #-1]
    6ec:        35fffe00        cbnz w0, 6ac <main+0x1c>
    6f0:        f947d42         ldr  x2, [x2, #4024]
    6f4:        90000000        adrp x0, 0 <_init-0x600>
    6f8:        91242000        add  x0, x0, #0×908
    6fc:        97ffffe1        bl   680 <printf@plt>
    700:        52800000        mov  w0, #0x0         // #0
    704:        a8c17bfd        ldp  x29, x30, [sp], #16
    708:        d65f03c0        ret
```

The compiler uses the `ADRP` instruction to load the values of pointers. We covered `ADR` in Chapter 5, “Thanks for the Memories”; `ADRP` works like `ADR`, *except* that it loads to a 4K page boundary. This means that it has a greater range than `ADR`, but for humans it’s harder to use. The compiler must set it to a page boundary, which in this case points to C runtime data and then uses cumbersome offsets to get to the correct data. This is good for compilers, not so good for humans to code.

### ADRP farFarAway

[ARM 64-Bit Assembly Language](https://www.amazon.com/64-Bit-Assembly-Language-Larry-Pyeatt/dp/0128192216/)

3 Load/store and branch instructions - 3.5 Branch instructions - 3.5.5 Form PC-relative address

The range of `adr` is just as limited as an unconditional `b` or a `bl`. To address a label that is a greater distance away, yet within 4 GB in either direction, the `adrp` instruction can be used.

> For the ARM processor, the `.space` and `.skip` directives are equivalent. This directive is very useful for declaring large arrays in the `.bss` section.

```asm linenums="1" hl_lines="11-12"
        .bss
closeBy:
        .word 0x00000000
        .skip 4000000000 // reserve 4G memory, filled with zero
farFarAway:
        .word 0xffffffff
        .text
        .type main, %function
        .global main
main:
        adrp x0, farFarAway
        add x0, x0, #:lo12:farFarAway

        ret
        .size main, (. - main)
```

A special notation(`#:lo12:`) is used to add only the lowest 12 bits of the label to the `ADRP` address. This fully calculates the label address because the 4 KB page is addressable with 12 bits.

- `adrp x0, :pg_hi21:farFarAway`: 4K page-aligned boundary
- `add x0, x0, #:lo12:farFarAway`: offset within page
